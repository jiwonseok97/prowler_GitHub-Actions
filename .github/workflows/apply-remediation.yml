name: Apply Remediation

on:
  pull_request:
    types: [opened, synchronize, closed]
    paths:
      - 'remediation/*.tf'

env:
  TF_BACKEND_BUCKET: prowler-terraform-state-132410971304
  TF_BACKEND_TABLE: prowler-terraform-locks
  TF_BACKEND_REGION: ap-northeast-2

permissions:
  contents: read
  id-token: write
  actions: write
  pull-requests: write

jobs:
  # -------------------------------------------------------
  # Plan: PR ì—´ë¦´ ë•Œ ì‹¤í–‰ â†’ plan ê²°ê³¼ë¥¼ PR ì½”ë©˜íŠ¸ë¡œ ê²Œì‹œ
  # -------------------------------------------------------
  plan:
    if: github.event.pull_request.merged != true && github.event.action != 'closed'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ap-northeast-2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Setup Infracost
        uses: infracost/actions/setup@v3
        with:
          api-key: ${{ secrets.INFRACOST_API_KEY }}  

      - name: Install IaC quality tools (tflint + tfsec)
        run: |
          curl -sSL -o /usr/local/bin/tfsec https://github.com/aquasecurity/tfsec/releases/latest/download/tfsec-linux-amd64
          chmod +x /usr/local/bin/tfsec
          curl -sSL -o /tmp/tflint.zip https://github.com/terraform-linters/tflint/releases/latest/download/tflint_linux_amd64.zip
          unzip -q /tmp/tflint.zip -d /tmp
          mv /tmp/tflint /usr/local/bin/tflint
          tflint --init

      - name: Collect changed files and group by category
        id: changed
        run: |
          files=$(git diff --name-status ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} -- 'remediation/*.tf' | awk '$1!="D"{print $NF}' | tr '\n' ' ')
          echo "files=$files" >> $GITHUB_OUTPUT

          # Extract unique categories from changed files
          # fix-iam_password_policy_xxx.tf â†’ iam
          # fix-cloudwatch_log_group_xxx.tf â†’ cloudwatch
          categories=""
          for file in $files; do
            base=$(basename "$file" .tf | sed 's/^fix-//')
            cat=$(echo "$base" | sed 's/_.*//')
            if ! echo "$categories" | grep -qw "$cat"; then
              categories="$categories $cat"
            fi
          done
          echo "categories=$(echo $categories | xargs)" >> $GITHUB_OUTPUT

      - name: Terraform Plan (per category)
        id: plan
        continue-on-error: true
        run: |
          set -euo pipefail
          : > /tmp/tfplan.txt
          : > /tmp/tfgate.txt
          exitcode=0

          if [ -z "${{ steps.changed.outputs.categories }}" ]; then
            echo "No remediation categories changed." >> /tmp/tfplan.txt
          else
            for category in ${{ steps.changed.outputs.categories }}; do
              echo "## Category: $category" >> /tmp/tfplan.txt
              echo "## Category: $category" >> /tmp/tfgate.txt
              work=$(mktemp -d)
              state_key="remediation/${category}.tfstate"

              # Copy ALL files for this category (not just changed ones)
              file_count=0
              for f in remediation/fix-${category}_*.tf; do
                [ -f "$f" ] || continue
                cp "$f" "$work/"
                file_count=$((file_count+1))
              done

              if [ "$file_count" -eq 0 ]; then
                echo "SKIP $category: no files found" | tee -a /tmp/tfplan.txt /tmp/tfgate.txt
                exitcode=1
                continue
              fi

              echo "  Files: $file_count" >> /tmp/tfplan.txt

              # Run cleanup on each file
              for tf in "$work"/*.tf; do
                python3 iac/scripts/cleanup_hcl.py "$tf"
              done

              # Deduplicate resource/data blocks across files
              python3 iac/scripts/dedup_resources.py "$work"

              # Check if any resource blocks remain
              if ! grep -rEq '^\s*resource\s+"' "$work"/*.tf 2>/dev/null; then
                echo "SKIP $category: no resource blocks after cleanup" | tee -a /tmp/tfplan.txt /tmp/tfgate.txt
                exitcode=1
                continue
              fi

              cat > "$work/backend.tf" <<EOF
          terraform {
            backend "s3" {
              bucket         = "${TF_BACKEND_BUCKET}"
              key            = "${state_key}"
              region         = "${TF_BACKEND_REGION}"
              dynamodb_table = "${TF_BACKEND_TABLE}"
              encrypt        = true
            }
          }
          EOF

              cat > "$work/provider.tf" <<'EOF'
          provider "aws" {
            region = "ap-northeast-2"
          }
          EOF

              cat > "$work/data.tf" <<'EOF'
          data "aws_caller_identity" "current" {}
          data "aws_region" "current" {}
          data "aws_partition" "current" {}
          EOF

              cat > "$work/.tflint.hcl" <<'EOF'
          rule "terraform_unused_declarations" {
            enabled = false
          }
          rule "terraform_required_providers" {
            enabled = false
          }
          rule "terraform_required_version" {
            enabled = false
          }
          EOF

              terraform -chdir="$work" init -input=false 2>&1 | tee -a /tmp/tfplan.txt
              if ! (cd "$work" && tflint -f compact 2>&1 | tee -a /tmp/tfgate.txt); then
                echo "SKIP $category: tflint failed" | tee -a /tmp/tfplan.txt /tmp/tfgate.txt
                exitcode=1
                continue
              fi
              # tfsec: ê²½ê³ ë§Œ ê¸°ë¡ (remediation ì½”ë“œ íŠ¹ì„±ìƒ blockingí•˜ì§€ ì•ŠìŒ)
              tfsec --no-colour "$work" 2>&1 | tee -a /tmp/tfgate.txt || echo "WARN $category: tfsec found issues (non-blocking)" | tee -a /tmp/tfplan.txt
              if ! terraform -chdir="$work" validate 2>&1 | tee -a /tmp/tfplan.txt /tmp/tfgate.txt; then
                echo "SKIP $category: validate failed" | tee -a /tmp/tfplan.txt /tmp/tfgate.txt
                exitcode=1
                continue
              fi
              terraform -chdir="$work" plan -no-color -out=tfplan.binary | tee -a /tmp/tfplan.txt
             
              terraform -chdir="$work" show -json tfplan.binary > "$work/plan.json"
              infracost breakdown --path "$work/plan.json" \
                --format json \
                --out-file "/tmp/infracost-${category}.json" 2>&1 | tee -a /tmp/tfplan.txt
                            if [ ${PIPESTATUS[0]} -ne 0 ]; then exitcode=1; fi
                          done
                        fi
                        
          # Merge all infracost outputs
          cost_files=""
          for f in /tmp/infracost-*.json; do
            [ -f "$f" ] && cost_files="$cost_files --path $f"
          done
          if [ -n "$cost_files" ]; then
            infracost output --format json $cost_files --out-file /tmp/infracost-total.json
            infracost output --format table $cost_files --out-file /tmp/infracost-table.txt
          fi
          echo "exitcode=$exitcode" >> "$GITHUB_OUTPUT"

      - name: Post Plan to PR comment
        uses: actions/github-script@v7
        env:
          PLAN_OUTPUT: ${{ steps.plan.outputs.exitcode }}
        with:
          script: |
           const fs = require('fs');
            let plan = fs.readFileSync('/tmp/tfplan.txt', 'utf8');
            if (plan.length > 50000) {
              plan = plan.substring(0, 50000) + '\n\n... (truncated)';
            }

            // Infracost ë¹„ìš© ì •ë³´ ì½ê¸°
            let costSection = '';
            try {
              const costTable = fs.readFileSync('/tmp/infracost-table.txt', 'utf8');
              const costJson = JSON.parse(fs.readFileSync('/tmp/infracost-total.json', 'utf8'));
              const monthly = costJson.totalMonthlyCost || '0';
              const emoji = parseFloat(monthly) > 10 ? 'ğŸ”´' : parseFloat(monthly) > 0 ? 'ğŸŸ¡' : 'ğŸŸ¢';
              costSection = `\n### ${emoji} ì˜ˆìƒ ì›” ë¹„ìš©: $${monthly}\n\n<details>\n<summary>ë¹„ìš© ìƒì„¸ ë³´ê¸° (í´ë¦­)</summary>\n\n\`\`\`\n${costTable}\n\`\`\`\n\n</details>\n`;
            } catch (e) {
              costSection = '\n### ğŸ’° ë¹„ìš© ì •ë³´ ì—†ìŒ (Infracost ì‹¤í–‰ ì‹¤íŒ¨)\n';
            }

            const exitcode = process.env.PLAN_OUTPUT;
            const status = exitcode === '0' ? 'âœ… Plan Succeeded' : 'âŒ Plan Failed';

            const body = `### Terraform Plan Result - ${status}
            ${costSection}
            <details>
            <summary>Plan ìƒì„¸ ë³´ê¸° (í´ë¦­)</summary>

            \`\`\`
            ${plan}
            \`\`\`

            </details>

            > ğŸ’¡ ì´ PRì„ ë¨¸ì§€í•˜ë©´ ìœ„ ë¦¬ì†ŒìŠ¤ê°€ AWSì— ìë™ ì ìš©ë©ë‹ˆë‹¤.`;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('Terraform Plan Result')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body,
              });
            }

      - name: Fail if plan failed
        if: steps.plan.outputs.exitcode != '0'
        run: exit 1

      - name: Upload quality gate logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: remediation-quality-gates
          path: /tmp/tfgate.txt
      
      - name: Upload cost estimate
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: remediation-cost-estimate
          path: /tmp/infracost-*.json

  # -------------------------------------------------------
  # Apply: PR ë¨¸ì§€ í›„ ì‹¤í–‰ â†’ ì‹¤ì œ AWS ì ìš©
  # -------------------------------------------------------
  apply:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ap-northeast-2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Install IaC quality tools (tflint + tfsec)
        run: |
          curl -sSL -o /usr/local/bin/tfsec https://github.com/aquasecurity/tfsec/releases/latest/download/tfsec-linux-amd64
          chmod +x /usr/local/bin/tfsec
          curl -sSL -o /tmp/tflint.zip https://github.com/terraform-linters/tflint/releases/latest/download/tflint_linux_amd64.zip
          unzip -q /tmp/tflint.zip -d /tmp
          mv /tmp/tflint /usr/local/bin/tflint
          tflint --init

      - name: Collect changed files and group by category
        id: changed
        run: |
          files=$(git diff --name-status ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} -- 'remediation/*.tf' | awk '$1!="D"{print $NF}' | tr '\n' ' ')
          echo "files=$files" >> $GITHUB_OUTPUT

          categories=""
          for file in $files; do
            base=$(basename "$file" .tf | sed 's/^fix-//')
            cat=$(echo "$base" | sed 's/_.*//')
            if ! echo "$categories" | grep -qw "$cat"; then
              categories="$categories $cat"
            fi
          done
          echo "categories=$(echo $categories | xargs)" >> $GITHUB_OUTPUT

      - name: Terraform Apply (per category)
        run: |
          set -euo pipefail
          : > /tmp/tfapply.txt
          applied=0
          skipped=0
          failed=0

          if [ -z "${{ steps.changed.outputs.categories }}" ]; then
            echo "No remediation categories changed."
            exit 0
          fi

          for category in ${{ steps.changed.outputs.categories }}; do
            echo "## Category: $category" >> /tmp/tfapply.txt
            work=$(mktemp -d)
            state_key="remediation/${category}.tfstate"

            # Copy ALL files for this category
            file_count=0
            for f in remediation/fix-${category}_*.tf; do
              [ -f "$f" ] || continue
              cp "$f" "$work/"
              file_count=$((file_count+1))
            done

            if [ "$file_count" -eq 0 ]; then
              echo "SKIP $category: no files found" | tee -a /tmp/tfapply.txt
              skipped=$((skipped+1))
              continue
            fi

            echo "  Files: $file_count" >> /tmp/tfapply.txt

            # Run cleanup on each file
            for tf in "$work"/*.tf; do
              python3 iac/scripts/cleanup_hcl.py "$tf"
            done

            # Deduplicate resource/data blocks across files
            python3 iac/scripts/dedup_resources.py "$work"

            # Check if any resource blocks remain
            if ! grep -rEq '^\s*resource\s+"' "$work"/*.tf 2>/dev/null; then
              echo "SKIP $category: no resource blocks after cleanup" | tee -a /tmp/tfapply.txt
              skipped=$((skipped+1))
              failed=1
              continue
            fi

            cat > "$work/backend.tf" <<EOF
          terraform {
            backend "s3" {
              bucket         = "${TF_BACKEND_BUCKET}"
              key            = "${state_key}"
              region         = "${TF_BACKEND_REGION}"
              dynamodb_table = "${TF_BACKEND_TABLE}"
              encrypt        = true
            }
          }
          EOF

            cat > "$work/provider.tf" <<'EOF'
          provider "aws" {
            region = "ap-northeast-2"
          }
          EOF

            cat > "$work/data.tf" <<'EOF'
          data "aws_caller_identity" "current" {}
          data "aws_region" "current" {}
          data "aws_partition" "current" {}
          EOF

            cat > "$work/.tflint.hcl" <<'EOF'
          rule "terraform_unused_declarations" {
            enabled = false
          }
          rule "terraform_required_providers" {
            enabled = false
          }
          rule "terraform_required_version" {
            enabled = false
          }
          EOF

            terraform -chdir="$work" init -input=false 2>&1 | tee -a /tmp/tfapply.txt
            if ! (cd "$work" && tflint -f compact 2>&1 | tee -a /tmp/tfapply.txt); then
              echo "SKIP $category: tflint failed" | tee -a /tmp/tfapply.txt
              failed=1
              continue
            fi
            # tfsec: ê²½ê³ ë§Œ ê¸°ë¡ (remediation ì½”ë“œ íŠ¹ì„±ìƒ blockingí•˜ì§€ ì•ŠìŒ)
            tfsec --no-colour "$work" 2>&1 | tee -a /tmp/tfapply.txt || echo "WARN $category: tfsec found issues (non-blocking)" | tee -a /tmp/tfapply.txt
            if ! terraform -chdir="$work" validate 2>&1 | tee -a /tmp/tfapply.txt; then
              echo "SKIP $category: validate failed" | tee -a /tmp/tfapply.txt
              failed=1
              continue
            fi
            if ! terraform -chdir="$work" plan -out=tfplan 2>&1 | tee -a /tmp/tfapply.txt; then
              echo "SKIP $category: plan failed" | tee -a /tmp/tfapply.txt
              failed=1
              continue
            fi
            if ! terraform -chdir="$work" apply -auto-approve tfplan 2>&1 | tee -a /tmp/tfapply.txt; then
              echo "SKIP $category: apply failed" | tee -a /tmp/tfapply.txt
              failed=1
              continue
            fi
            applied=$((applied+1))
          done

          echo "applied=$applied skipped=$skipped failed=$failed" >> /tmp/tfapply.txt
          if [ "$applied" -eq 0 ]; then
            echo "No categories applied. Failing job." | tee -a /tmp/tfapply.txt
            exit 1
          fi
          if [ "$failed" -ne 0 ]; then
            echo "One or more categories failed. Failing job." | tee -a /tmp/tfapply.txt
            exit 1
          fi

      - name: Trigger Prowler Re-scan
        run: |
          gh workflow run prowler-security-scan.yml
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload apply logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: remediation-apply-logs
          path: /tmp/tfapply.txt
